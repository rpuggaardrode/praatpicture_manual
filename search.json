[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Make Praat Picture-style plots of acoustic data in R",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Make Praat Picture-style plots of acoustic data in R",
    "section": "Getting started",
    "text": "Getting started\nMany phoneticians and linguists use R for a big portion of their data processing and analysis pipeline, and increasingly also for preparing manuscripts and presentations using the RMarkdown and Quarto formats. A big advantage of these formats is the ability to generate plots on the fly using R code. A very important visualization in the phonetician’s arsenal shows one or more time-aligned signals (such as waveform, spectrogram, or pitch) together with an annotation. These are usually made in Praat. praatpicture – named in tribute of Praat’s plotting GUI – implements this kind of visualization as a base R plot. The package provides easy and fast out-of-the-box solutions but also a high extent of flexibility.\nVersion 1.6.2 of praatpicture is in the R package repository CRAN, and can be installed with the following command:\n\ninstall.packages('praatpicture')\n\npraatpicture is being continuously updated, and the current development version can always be installed from GitHub. Bug fixes and new functionality will be introduced in the development version before they are introduced to CRAN. You can install the development version using the package devtools like so:\n\ndevtools::install_github('rpuggaardrode/praatpicture')\n\nYou can now load the library and make a Praat Picture style-plot using a very simple praatpicture() command pointing to the name of a sound file with the .wav extension:\n\nlibrary(praatpicture)\npraatpicture('ex/index.wav')\n\n\n\n\n\n\n\n\npraatpicture has many other options and functions for customizing these figures. These are covered in detail in the following chapters."
  },
  {
    "objectID": "index.html#citing-praatpicture",
    "href": "index.html#citing-praatpicture",
    "title": "Make Praat Picture-style plots of acoustic data in R",
    "section": "Citing praatpicture",
    "text": "Citing praatpicture\nA fair amount of time goes into making praatpicture, so if you use it for publications, please consider citing it!\nYou can either cite the R package directly, or refer to this paper:\nPuggaard-Rode, Rasmus (2024) praatpicture. A library for making flexible Praat Picture-style figures in R. In Cécile Fougeron & Pascal Perrier (eds.), Proceedings of the 13th International Seminar on Speech Production, 115–118."
  },
  {
    "objectID": "index.html#crucial-libraries-and-data-sources",
    "href": "index.html#crucial-libraries-and-data-sources",
    "title": "Make Praat Picture-style plots of acoustic data in R",
    "section": "Crucial libraries and data sources",
    "text": "Crucial libraries and data sources\nThe following libraries are crucial for the functionality of praatpicture:\n\nav is used to make MP4 videos with embedded audio and animations\nemuR is used for EMU-SDMS integration\ngifski is used to make GIF animations\ngsignal is used for power-to-decibel conversion\nipa is used to dynamically convert SAMPA to IPA\nphonTools is used to generate spectrograms\nrPraat is used to import TextGrids and derived signals calculated in Praat into R\nsoundgen is used to used for Hertz-to-ERB conversion\ntuneR is used to import WAV files into R\nwrassp is used for calculating pitch, formants, and intensity on the fly\n\nThe Shiny implementation relies on the shiny, shinyjs, and bslib libraries.\nThe data used for illustrations in this manual come from a few different sources:\n\nThis repository with recordings in Eastern Khmu’ associated with a paper from Kirby et al. 2023\nMultichannel data in Tzotzil was shared with me by Heriberto Avelino\nDanish data was gathered by myself. You hear and see the voice of Søren Sandager Sørensen"
  },
  {
    "objectID": "index.html#bug-reports-suggestions-ideas",
    "href": "index.html#bug-reports-suggestions-ideas",
    "title": "Make Praat Picture-style plots of acoustic data in R",
    "section": "Bug reports, suggestions, ideas",
    "text": "Bug reports, suggestions, ideas\nIf you run into any problems using praatpicture, I’m very happy to hear about them! Feel free to file an issue on GitHub, or reach out via e-mail."
  },
  {
    "objectID": "basics.html#showing-part-of-a-sound-file",
    "href": "basics.html#showing-part-of-a-sound-file",
    "title": "1  Basic usage",
    "section": "1.1 Showing part of a sound file",
    "text": "1.1 Showing part of a sound file\nVery often you won’t want to plot an entire sound file. You can choose exactly which part of a sound file to plot with the start and end arguments, giving the start and end times of the plotted portion of the file in seconds:\n\npraatpicture('ex/ex.wav', \n             start = 1.2)\n\n\n\n\n\n\n\n\n\npraatpicture('ex/ex.wav',\n             end = 0.275)"
  },
  {
    "objectID": "basics.html#what-to-plot",
    "href": "basics.html#what-to-plot",
    "title": "1  Basic usage",
    "section": "1.2 What to plot?",
    "text": "1.2 What to plot?\nBy default, praatpicture() plots a waveform, a spectrogram, and annotations. This is controlled with the frames argument, which takes any combination of the following options:\n\nsound\nspectrogram\nTextGrid\npitch\nformant\nintensity\n\nThe default is to plot the first three, but we could also swap the spectrogram for formants:\n\npraatpicture('ex/ex.wav', \n             end = 0.275,\n             frames = c('sound', 'formant', 'TextGrid'))\n\n\n\n\n\n\n\n\nOr we could plot more frames:\n\npraatpicture('ex/ex.wav', \n             end = 0.275,\n             frames = c('sound', 'spectrogram', 'intensity', 'TextGrid'))\n\n\n\n\n\n\n\n\nOr we could plot just a spectogram:\n\npraatpicture('ex/ex.wav', \n             end = 0.275,\n             frames = 'spectrogram')"
  },
  {
    "objectID": "basics.html#relative-sizes-of-plot-components",
    "href": "basics.html#relative-sizes-of-plot-components",
    "title": "1  Basic usage",
    "section": "1.3 Relative sizes of plot components",
    "text": "1.3 Relative sizes of plot components\nWhen using the default frames, the waveform is relatively small, the spectrogram is larger, and the annotations are smaller than either. When using more or less frames, they are all the same size. This can be controlled with the proportion argument, which gives the percentage in size of each component. The default is c(30,50,20), i.e. 30% waveform, 50% spectrogram, and 20% annotation.\nThe following reduces the size of the waveform and annotations to 15% each, and increases the size of the spectrogram to 70%:\n\npraatpicture('ex/ex.wav', \n             start = 1.2,\n             proportion = c(15,70,15))\n\n\n\n\n\n\n\n\n(It doesn’t really have to be percentages – passing c(3,5,2) for example would give the same result)."
  },
  {
    "objectID": "basics.html#axis-appearance",
    "href": "basics.html#axis-appearance",
    "title": "1  Basic usage",
    "section": "1.4 Axis appearance",
    "text": "1.4 Axis appearance\nIn accordance with Praat default settings, the default is to show only start and end times on the x-axis. This can be controlled with the start_end_only argument, which by default is set to TRUE:\n\npraatpicture('ex/ex.wav', \n             start = 1.2,\n             start_end_only = FALSE)\n\n\n\n\n\n\n\n\nThe x-axis starts at 0 by default even though in this case we actually start plotting 1.2 seconds into the sound file. This can be changed with the tfrom0 argument, which is also TRUE by default:\n\npraatpicture('ex/ex.wav', \n             start = 1.2,\n             start_end_only = FALSE,\n             tfrom0 = FALSE)\n\n\n\n\n\n\n\n\nYou can change the x-axis label using the time_axisLabel argument. If you prefer “Time in seconds” to “Time (s)”, this is easily done:\n\npraatpicture('ex/ex.wav', \n             start = 1.2,\n             time_axisLabel = 'Time in seconds')\n\n\n\n\n\n\n\n\nIf you prefer your x-axis to be based on milliseconds rather than seconds, you can control this with the tUnit argument, which should then be set to tUnit = 'ms'.\n\npraatpicture('ex/ex.wav', \n             start = 1.2,\n             tUnit = 'ms')\n\n\n\n\n\n\n\n\nThe y-axes, like the x-axes, also show only axis limits by default. This can be changed globally using the min_max_only argument, which is TRUE by default:\n\npraatpicture('ex/ex.wav', \n             start = 1.2,\n             start_end_only = FALSE,\n             min_max_only = FALSE)\n\n\n\n\n\n\n\n\nAs with the x-axis label, the y-axis labels can also all be controlled with specific arguments like pitch_axisLabel or other *_axisLabel arguments. We’ll cover this in the following sections."
  },
  {
    "objectID": "basics.html#adding-a-title",
    "href": "basics.html#adding-a-title",
    "title": "1  Basic usage",
    "section": "1.5 Adding a title",
    "text": "1.5 Adding a title\nThe argument mainTitle can be used to add a title on top of your plot, like this:\n\npraatpicture('ex/ex.wav', \n             start = 1.2,\n             mainTitle = 'I am a happy little plot')\n\n\n\n\n\n\n\n\nYou can control the vertical aligment of the title with the mainTitleAlignment argument. This has to be a number between 0 and 1, where 0 is the left edge of the plot and 1 is the right edge of the plot. As such, 0.5 is a central title:\n\npraatpicture('ex/ex.wav', \n             start = 1.2,\n             mainTitle = 'I am a happy little plot',\n             mainTitleAlignment = 0.5)\n\n\n\n\n\n\n\n\nThe title can be placed anywhere – this one is further to the right:\n\npraatpicture('ex/ex.wav', \n             start = 1.2,\n             mainTitle = 'I am a happy little plot',\n             mainTitleAlignment = 0.8)"
  },
  {
    "objectID": "shiny.html",
    "href": "shiny.html",
    "title": "2  Shiny app",
    "section": "",
    "text": "The most flexible way to use the praatpicture library and the best way to integrate plots in your R documents is with the praatpicture() function. But if you just want to make a quick plot and you’d rather not go through the hassle of learning all the argument names, you can use a graphical user interface (a so-called “Shiny app”) instead. This is still in a somewhat experimental stage and is not as full-featured, but should be sufficient for most purposes. Be aware, though, that the Shiny app currently limits file sizes to 5MB, so this only works with short audio files.\nSimply run the following code:\n\nshiny_praatpicture()\n\nAnd the following window should appear:\n\n\n\n\n\nIf you upload a sound file, it will be plotted immediately:\n\n\n\n\n\nBy expanding the menu items on the left, you can access most of the same arguments that you can toggle using the praatpicture() function; they’re all explained in the following chapters.\nFor example, if you expand the menu item “General apperance”, you’ll see the option “Which frames should be plotted?”. If you add TextGrid, you’ll be prompted to upload a .TextGrid file:\n\n\n\n\n\nOnce you’ve uploaded this, the plot will regenerate automatically:\n\n\n\n\n\nGenerally, whenever you change one of the parameters, the plot will regenerate automatically. Once you’re done editing your plot, simply click the “Download” button."
  },
  {
    "objectID": "waveform.html#managing-channels",
    "href": "waveform.html#managing-channels",
    "title": "3  The waveform",
    "section": "3.1 Managing channels",
    "text": "3.1 Managing channels\npraatpicture() has the option of plotting multiple channels. By default, all channels are plotted. If you have a stereo sound file, it will look like this:\n\npraatpicture('ex/index_stereo.wav', \n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30))\n\n\n\n\n\n\n\n\nYou may not want this; if you prefer plotting just a single channel, you can controls this with the wave_channels argument. For plotting just the second channel:\n\npraatpicture('ex/index_stereo.wav', \n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30),\n             wave_channels = 2)\n\n\n\n\n\n\n\n\nAs indicated above, it is also possible plot audio with more than two channels, like in this case, where one channel captures audio, and other channels capture various articulatory signals:\n\npraatpicture('ex/multichannel.wav', \n             start = 0.6, end = 2.4,\n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30))\n\n\n\n\n\n\n\n\nThe argument wave_channels can be used to both extract and reorder channels. Here we omit the second channel, and swap the order of the third and fourth channels:\n\npraatpicture('ex/multichannel.wav', \n             start = 0.6, end = 2.4,\n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30),\n             wave_channels = c(1,4,3))"
  },
  {
    "objectID": "waveform.html#labelling-channels",
    "href": "waveform.html#labelling-channels",
    "title": "3  The waveform",
    "section": "3.2 Labelling channels",
    "text": "3.2 Labelling channels\nThe argument wave_channelNames can be used to add labels next to the y-axis with channel names. It is set to FALSE by default. If we plot stereo data with wave_channelNames set to TRUE, it’ll by default print the labels “left” and “right” next to the channels:\n\npraatpicture('ex/index_stereo.wav', \n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30),\n             wave_channelNames = TRUE)\n\n\n\n\n\n\n\n\nInstead of passing a logical argument like TRUE, we can also pass a vector of strings and thus control the channel labels:\n\npraatpicture('ex/index_stereo.wav', \n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30),\n             wave_channelNames = c('above', 'below'))\n\n\n\n\n\n\n\n\nThis is especially useful in cases like our multichannel data above, where we can then label the sources of the signals:\n\npraatpicture('ex/multichannel.wav', \n             start = 0.6, end = 2.4,\n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30),\n             wave_channelNames = c('audio', 'airflow', 'EGG', 'Pio'))\n\n\n\n\n\n\n\n\nYou can of course also label just a single channel:\n\npraatpicture('ex/index.wav', \n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30),\n             wave_channelNames = 'wave')"
  },
  {
    "objectID": "waveform.html#coloring-options",
    "href": "waveform.html#coloring-options",
    "title": "3  The waveform",
    "section": "3.3 Coloring options",
    "text": "3.3 Coloring options\nThe argument wave_color allows users to control the color of the waveform. By default it is set to black; when plotting waveforms along with spectrogram, it is often the spectrogram in focus, so it can make a lot of sense to give the waveform a lighter grey color like so:\n\npraatpicture('ex/index.wav', \n             wave_color='grey')\n\n\n\n\n\n\n\n\nWhen multichannel data are plotted, it is also possible to assign different colors to different channels, by passing a vector instead of a single string to wave_color.\n\npraatpicture('ex/multichannel.wav', \n             start = 0.6, end = 2.4,\n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30),\n             wave_channelNames = c('audio', 'airflow', 'Pio', 'EGG'),\n             wave_color=c('red', 'black', 'orange', 'blue'))"
  },
  {
    "objectID": "waveform.html#line-width",
    "href": "waveform.html#line-width",
    "title": "3  The waveform",
    "section": "3.4 Line width",
    "text": "3.4 Line width\nThe width of the waveform line can be controlled with the wave_lineWidth argument. If you’re plotting a very complex wave, it can be helpful to pass a number smaller than 1, which is the default:\n\npraatpicture('ex/index.wav', \n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30),\n             wave_lineWidth = 0.5)\n\n\n\n\n\n\n\n\nYou typically won’t want to pass a number larger than 1, but it could make sense if you’re plotting only a very short sound snippet."
  },
  {
    "objectID": "waveform.html#appearance-of-the-y-axis",
    "href": "waveform.html#appearance-of-the-y-axis",
    "title": "3  The waveform",
    "section": "3.5 Appearance of the y-axis",
    "text": "3.5 Appearance of the y-axis\nThe energy range shown on the y-axis can be controlled with the wave_energyRange argument. By default it is simply set to follow the minima and maxima in the signal, but you can set your own values by passing a vector of two numbers. Here we increase the amount of white space in the waveform:\n\npraatpicture('ex/index.wav', \n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30),\n             wave_energyRange = c(-0.1, 0.1))\n\n\n\n\n\n\n\n\nThis could for example be useful if you want to add text or arrows to the waveform plot, as we will see later in Chapter 9.\nThis can also be useful if two different wave channels with different information are being plotted, and we want to ensure that the energy range is comparable:\n\npraatpicture('ex/multichannel.wav', \n             start = 0.6, end = 2.4,\n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30),\n             wave_channelNames = c('audio', 'airflow', 'Pio', 'EGG'),\n             wave_color=c('red', 'black', 'orange', 'blue'),\n             wave_energyRange = c(-1, 1))\n\n\n\n\n\n\n\n\nOf course, these signals aren’t really all that comparable in the first place, but it’s easy to imagine a situation where they would be. For example when plotting the oral and nasal channel from a nasalance device.\nThe number of digits to be printed along the y-axis can be controlled with the wave_axisDigits argument. By default, 3 digits are shown, but it’s easy to print more if you want:\n\npraatpicture('ex/index.wav', \n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30),\n             wave_axisDigits = 5)\n\n\n\n\n\n\n\n\nOften, these exact values don’t tell us all that much. You can suppress the y-axis entirely by setting wave_axisDigits = 0:\n\npraatpicture('ex/index.wav', \n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30),\n             wave_axisDigits = 0)"
  },
  {
    "objectID": "TextGrid.html#managing-tiers",
    "href": "TextGrid.html#managing-tiers",
    "title": "4  The TextGrid",
    "section": "4.1 Managing tiers",
    "text": "4.1 Managing tiers\nThe above figure has six annotation tiers, which is probably not an unusual situation, but in these cases it’s also nice to have the option of not plotting all of them. This behavior can be controlled with the tg_tiers argument. If we only want to plot the first tier, we can do the following:\n\npraatpicture('ex/tg.wav', \n             tg_tiers = 1)\n\n\n\n\n\n\n\n\nWe can also index tiers by their names instead of numbers. If we wanted to plot only the vot tier with voice onset time related landmarks:\n\npraatpicture('ex/tg.wav', \n             tg_tiers = 'vot')\n\n\n\n\n\n\n\n\nWe can index as many tiers as we want this way, and can also use it to change the order in which tiers are plotted:\n\npraatpicture('ex/tg.wav', \n             tg_tiers = c('vot', 'phone', 'word'))"
  },
  {
    "objectID": "TextGrid.html#vertical-lines-throughout-plots",
    "href": "TextGrid.html#vertical-lines-throughout-plots",
    "title": "4  The TextGrid",
    "section": "4.2 Vertical lines throughout plots",
    "text": "4.2 Vertical lines throughout plots\nWhen combining annotations with signals, you will by default see vertical lines throughout all plot components corresponding to boundaries in the first annotation tier. This is unlike in Praat, where you will by default see lines corresponding to all annotation tiers. This behavior is controlled with the tg_focusTier argument; a “focus tier” is the term we use for (a) tier(s) important enough to be shown throughout all plot components.\ntg_focusTier is by default set to 1, i.e. the first tier. It also understands all, corresponding to the Praat defaults:\n\npraatpicture('ex/tg.wav', \n             tg_tiers = c('vot', 'phone', 'word'),\n             tg_focusTier = 'all')\n\n\n\n\n\n\n\n\nIf you want to plot annotations but aren’t interested in these vertical lines, tg_focusTier also understands none:\n\npraatpicture('ex/tg.wav', \n             tg_tiers = c('vot', 'phone', 'word'),\n             tg_focusTier = 'none')\n\n\n\n\n\n\n\n\nOr you can pass a vector of which tiers should be highlighted.\nThe argument tg_focusTierLineType controls the vertical line type. The default is dotted, but you can use any of the base R plotting line types, fx longdash:\n\npraatpicture('ex/tg.wav', \n             tg_tiers = c('vot', 'phone', 'word'),\n             tg_focusTier = c('vot', 'phone'),\n             tg_focusTierLineType = 'longdash')\n\n\n\n\n\n\n\n\nIf you have multiple “focus tiers” as above, it’s possible to use different line types for different tiers by passing a vector to tg_focusTierLineType. This can help differentiate the ‘source’ of the different vertical lines.\n\npraatpicture('ex/tg.wav', \n             tg_tiers = c('vot', 'phone', 'word'),\n             tg_focusTier = c('vot', 'phone'),\n             tg_focusTierLineType = c('dashed', 'solid'))\n\n\n\n\n\n\n\n\nA similar result can be achieved with coloring, as shown below."
  },
  {
    "objectID": "TextGrid.html#coloring-options",
    "href": "TextGrid.html#coloring-options",
    "title": "4  The TextGrid",
    "section": "4.3 Coloring options",
    "text": "4.3 Coloring options\nAnnotation text is black by default, but the color of annotations can be controlled with the tg_color argument. Fx if we want blue annotations:\n\npraatpicture('ex/tg.wav', \n             tg_tiers = c('vot', 'phone', 'word'),\n             tg_color = 'blue')\n\n\n\n\n\n\n\n\nThe color of vertical lines corresponding to annotation boundaries can be controlled with the tg_focusTierColor argument. For blue solid lines, we can use the following code:\n\npraatpicture('ex/tg.wav', \n             tg_tiers = c('vot', 'phone', 'word'),\n             tg_color = 'blue',\n             tg_focusTierLineType = 'solid',\n             tg_focusTierColor = 'blue')\n\n\n\n\n\n\n\n\nYou can pass multiple values to tg_color if you want the different tiers to have different colors:\n\npraatpicture('ex/tg.wav', \n             tg_tiers = c('vot', 'phone', 'word'),\n             tg_color = c('blue', 'orange', 'black'))\n\n\n\n\n\n\n\n\nThis can be especially useful if you have multiple “focus tiers”, because you can then use a coloring scheme to show which vertical lines correspond to which colors, like so:\n\npraatpicture('ex/tg.wav', \n             tg_tiers = c('vot', 'phone', 'word'),\n             tg_color = c('blue', 'orange', 'black'),\n             tg_focusTier = 'all',\n             tg_focusTierLineType = c('solid', 'solid', 'dashed'),\n             tg_focusTierColor = c('blue', 'orange', 'black'))\n\n\n\n\n\n\n\n\nIn this case, the line types are also differentiated to show when the phone and word boundaries overlap with a dashed orange/black line."
  },
  {
    "objectID": "TextGrid.html#tier-labels",
    "href": "TextGrid.html#tier-labels",
    "title": "4  The TextGrid",
    "section": "4.4 Tier labels",
    "text": "4.4 Tier labels\nBy default, the names of annotation tiers are plotted next to the tiers. Praat does not do this by default. It can be controlled with the tg_tierNames argument, which is TRUE by default.\n\npraatpicture('ex/tg.wav', \n             tg_tiers = c('vot', 'phone', 'word'),\n             tg_tierNames = FALSE)"
  },
  {
    "objectID": "TextGrid.html#sec-typesetting",
    "href": "TextGrid.html#sec-typesetting",
    "title": "4  The TextGrid",
    "section": "4.5 Praat-style typesetting",
    "text": "4.5 Praat-style typesetting\nPraat has some shortcuts used for special typesetting in TextGrids:\n\n% will turn the following symbol italic;\n# will turn the following symbol bold;\n#% will turn the following symbol bold italic;\n^ will superscript the following symbol;\n_ will subscript the following symbol;\nSymbols wrapped in \\s{...} will be rendered in small caps;\nSymbols wrapped in %% ... % will all be italic, and the same with ## ... #, ^^ ... ^, etc.\n\npraatpicture does not emulate this behavior with default:\n\npraatpicture('ex/tg.wav',\n             tg_tiers = c('word', 'gloss', 'ort', 'trans'))\n\n\n\n\n\n\n\n\nIt can however be emulated by setting the argument tg_specialChar to TRUE:\n\npraatpicture('ex/tg.wav',\n             tg_tiers = c('word', 'gloss', 'ort', 'trans'),\n             tg_specialChar = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhy isn’t special typesetting used by default?\n\n\n\nThere are a few reasons for this, one being that this special typesetting will make phonetic transcriptions using X-SAMPA render very weirdly. Another reason is that in order to vary the typeface like this in a base R plot, the text cannot be rendered as a string, but must be rendered as an expression, which is a different type of object in R. For some obscure reason lost to time, vertical alignment works slightly differently for strings and expressions, which can mean that text isn’t perfectly centrally aligned when tg_specialChar = TRUE; more details in help(text).\n\n\n\n\n\n\n\n\nOther Praat-flavored special typesetting shortcuts do not work!\n\n\n\nPraat also has a whole bunch of codes for rendering special symbols, including IPA characters. These are not implemented praatpicture (yet), but any Unicode character in a TextGrid should render just fine."
  },
  {
    "objectID": "TextGrid.html#horizontal-alignment",
    "href": "TextGrid.html#horizontal-alignment",
    "title": "4  The TextGrid",
    "section": "4.6 Horizontal alignment",
    "text": "4.6 Horizontal alignment\nThe default is for annotations to be horizontally aligned in the middle of intervals, but it’s also possibly to right-align or left-align them. This is controlled with the tg_alignment argument.\nHere the text is right-aligned:\n\npraatpicture('ex/tg.wav',\n             tg_tiers = c('phone', 'word', 'gloss', 'ort', 'trans'),\n             tg_specialChar = TRUE,\n             tg_alignment = 'right')\n\n\n\n\n\n\n\n\nThe alignment doesn’t have to be the same for every tier. For example, you might want the regular central alignment for the phone and word tiers, but for the rest it might make sense to have them left-aligned. This can be achieved as follows:\n\npraatpicture('ex/tg.wav',\n             tg_tiers = c('phone', 'word', 'gloss', 'ort', 'trans'),\n             tg_specialChar = TRUE,\n             tg_alignment = c('central', 'central', \n                              'left', 'left', 'left'))"
  },
  {
    "objectID": "spec.html#appearance",
    "href": "spec.html#appearance",
    "title": "5  The spectrogram",
    "section": "5.1 Appearance",
    "text": "5.1 Appearance\n\n5.1.1 Frequency range\nThe spectrogram by default shows a frequency range between 0–5,000 Hz. The frequency range can be controlled with the spec_freqRange argument. For example, here we’ve removed the lowest frequencies (&lt; 200 Hz), and extended the upper range to 10,000 Hz. This can be useful when you want to see what’s going on with sibilant-like sounds!\n\npraatpicture('ex/tg.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             spec_freqRange = c(200,10000))\n\n\n\n\n\n\n\n\n\n\n5.1.2 Dynamic range\nThe dynamic range of the spectrogram is set to 50 dB by default, meaning that energy below 50 dB under the maximum amplitude in the spectrogram is rendered as white. This can be controlled with the spec_dynamicRange argument. The current Praat default is actually a bit higher, namely 70 dB, as shown here:\n\npraatpicture('ex/tg.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             spec_dynamicRange = 70)\n\n\n\n\n\n\n\n\nA very high dynamic range will give a spectrogram without any white areas:\n\npraatpicture('ex/tg.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             spec_dynamicRange = 150)\n\n\n\n\n\n\n\n\nAnd with a very low dynamic range, only areas with very high energy is shown:\n\npraatpicture('ex/tg.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             spec_dynamicRange = 30)\n\n\n\n\n\n\n\n\n\n\n5.1.3 Coloring options\nBy default, areas of the specrogram with low energy are rendered in white and areas with energy in black. This is controlled with the spec_color argument, which should be at least two colors. For example, you could render high frequencies in blue like so:\n\npraatpicture('ex/tg.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             spec_color = c('white', 'blue'))\n\n\n\n\n\n\n\n\nIt is also possible to use more complicated color schemes, by specifying both the color used for lowest values, highest values, and any number of in-between values. For example, this plot uses brown for high values, white for low values, and a bunch of pink-ish hues for in-between values\n\npraatpicture('ex/tg.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             spec_color = c('white', 'pink', 'magenta', 'purple', 'brown'))\n\n\n\n\n\n\n\n\n\n\n5.1.4 Axis label\nThe label along the y-axis says Frequency (Hz) by default. This is controlled with the spec_axisLabel argument; here’s one that just says Spectrogram:\n\npraatpicture('ex/tg.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             spec_axisLabel = 'Spectrogram')"
  },
  {
    "objectID": "spec.html#signal-processing",
    "href": "spec.html#signal-processing",
    "title": "5  The spectrogram",
    "section": "5.2 Signal processing",
    "text": "5.2 Signal processing\n\n5.2.1 Source signal\nWhen plotting multi-channel data, the spectrogram is always based on one of the channels. By default it is the first one, as shown here:\n\npraatpicture('ex/multichannel.wav',\n             start = 0.6, end = 2.4,\n             frames = c('sound', 'spectrogram'))\n\n\n\n\n\n\n\n\nIf we were interested in using a different channel for the spectrogram, the spec_channel argument can be used for that purpose. Here’s a spectrogram showing the EGG signal:\n\npraatpicture('ex/multichannel.wav',\n             start = 0.6, end = 2.4,\n             frames = c('sound', 'spectrogram'),\n             spec_channel = 4)\n\n\n\n\n\n\n\n\n\n\n5.2.2 Window length\nThe default window length used for generating spectra is 5 ms, following Praat. This gives you a narrowband spectrogram. Window length is controlled with the spec_windowLength argument. For example, using 30 ms will give you a broadband spectrogram. This has lower temporal resolution, but is great for seeing the harmonics!\n\npraatpicture('ex/tg.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             spec_windowLength = 0.03)\n\n\n\n\n\n\n\n\n\n\n5.2.3 Window shape\nSpectra are generated with Gaussian windows by default, but a range of other shapes are available. A bunch of other options are available, although the difference between most of them is marginal. Gaussian window shapes are a bit slower, but the difference is small enough that it should make a difference for most users.\nThis uses Hamming windows:\n\npraatpicture('ex/tg.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             spec_windowShape = 'Hamming')\n\n\n\n\n\n\n\n\nHanning windows:\n\npraatpicture('ex/tg.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             spec_windowShape = 'Hanning')\n\n\n\n\n\n\n\n\nBartlett windows:\n\npraatpicture('ex/tg.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             spec_windowShape = 'Bartlett')\n\n\n\n\n\n\n\n\nAnd here square (or ‘rectangular’) windows, which is equivalent to an un-edited window. These spectrograms clearly look worse:\n\npraatpicture('ex/tg.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             spec_windowShape = 'square')\n\n\n\n\n\n\n\n\n\n\n5.2.4 Time step\nBy default, spectrograms are composed of 1,000 spectral slices. This is controlled with the spec_timeStep argument. Lowering this will speed up generating the spectrogram, but the spectrogram will likely look pixellated. Here is one composed from “only” 200 spectral slices:\n\npraatpicture('ex/tg.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             spec_timeStep = 200)\n\n\n\n\n\n\n\n\n500 spectral slices will usually be enough to render a spectrogram that doesn’t look pixellated, and will also speed up generating the spectrogram a fair bit.\n\npraatpicture('ex/tg.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             spec_timeStep = 500)\n\n\n\n\n\n\n\n\nIf you’re printing a really large plot, that might not be enough though. 1,000 is enough for most purposes, but again, if you’re printing something very large, you may want to set a higher time step."
  },
  {
    "objectID": "pitch.html#appearance",
    "href": "pitch.html#appearance",
    "title": "6  Pitch",
    "section": "6.1 Appearance",
    "text": "6.1 Appearance\n\n6.1.1 Plot type\nWhen plotting pitch in Praat, pitch tracks are either ‘drawn’ or ‘speckled’. The default is ‘drawn’, i.e. line plots:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey')\n\n\n\n\n\n\n\n\nThis can be controlled with the pitch_plotType argument. A ‘speckled’ plot will draw points for the individual pitch measures:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle')\n\n\n\n\n\n\n\n\nIf you want to draw a pitch contour with a thicker line, you can set the drawSize argument larger than 1 (which will also affect other drawn derived signals, i.e. formants or intensity).\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             drawSize = 3)\n\n\n\n\n\n\n\n\nThe speckleSize argument works similarly if you want larger points in a speckled plot.\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             speckleSize = 2)\n\n\n\n\n\n\n\n\nIf you want smaller speckles, you can set speckleSize lower, e.g. 0.5.\n\n\n6.1.2 Frequency range\nThe default frequency range for pitch plots shows between 50–500 Hz. This is rather broad for most purposes. Frequency range can be controlled with the pitch_freqRange argument. Here, a frequency range between 80–250 Hz is probably more suitable:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_freqRange = c(80,250))\n\n\n\n\n\n\n\n\n\n\n6.1.3 Scale\nBy default, pitch tracks are plotted in a raw frequency scale. A range of other options are available for scaling the pitch values. This is controlled with the pitch_scale argument.\nlog or logarithmic will both produce a plot that is log-scaled on the y-axis.\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_scale = 'log')\n\n\n\n\n\n\n\n\nNotice that the y-axis label changes automatically to reflect the scale.\nOther scales have different default frequency ranges. The equivalent rectangular bandwidth (ERB) scale by default goes from 1–10:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_scale = 'erb')\n\n\n\n\n\n\n\n\nThis can of course still be controlled, here is 2.5–7.5 for example:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_freqRange = c(2.5,7.5),\n             pitch_scale = 'erb')\n\n\n\n\n\n\n\n\nAlthough be careful that the frequency range fits with the scale. Setting a frequency range between, say, 80–250 (suitable for Hz) for an ERB-scaled plot will simply produce an empty plot:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_freqRange = c(80,250),\n             pitch_scale = 'erb')\n\n\n\n\n\n\n\n\nIt is also possible to produce Mel-scaled plots:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_scale = 'mel')\n\n\n\n\n\n\n\n\nAnd finally semitones:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_scale = 'semitones')\n\n\n\n\n\n\n\n\nThe default reference level for semitones is 100 Hz; this can be controlled with the pitch_semitonesRe argument. This speaker probably has a mean pitch closer to 140 Hz, so we could set the semitones reference to match that:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_scale = 'semitones',\n             pitch_semitonesRe = 140)\n\n\n\n\n\n\n\n\n\n\n6.1.4 Coloring options\nThe color of the pitch trace is controlled with the pitch_color argument. Here’s a blue contour:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_color = 'blue')\n\n\n\n\n\n\n\n\nSome fancier coloring options are available when a pitch track is overlaid on spectrograms or waveforms; more on that in Section 6.1.6 and Section 6.2.\n\n\n6.1.5 Axis label\nAs we’ve seen above, the y-axis label for pitch plots is automatically adapted to different frequency scales. Users can also specify their own axis labels, using the pitch_axisLabel argument. For example, we might want to refer to it as f0:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_axisLabel = 'f0 (Hz)')\n\n\n\n\n\n\n\n\n\n\n6.1.6 Overlaying on spectrogram\nInstead of drawing pitch in its own frame, it is also possible to overlay a pitch contour on a spectrogram. In this case, pitch should not be specified as one of the frames; this is instead controlled with the Boolean pitch_plotOnSpec argument.\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_plotOnSpec = TRUE)\n\n\n\n\n\n\n\n\nThe other arguments controlling pitch appearance (and signal processing) also work when overlaying pitch on the spectrogram:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_plotOnSpec = TRUE,\n             pitch_color = 'blue',\n             pitch_freqRange = c(80,250),\n             pitch_axisLabel = 'f0 (Hz)')\n\n\n\n\n\n\n\n\nNotice that the y-axis label will match the color of the pitch trace.\nWhen overlaying a pitch trace on a spectrogram, there is the added option of having a wider line with a separate background color, which helps the trace stand out more. For example, we may want the pitch trace in the above plot to have a light blue background color. In this case, we can pass a vector to pitch_color specifying first the main color, and then the background:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_plotOnSpec = TRUE,\n             pitch_color = c('blue', 'lightblue'),\n             pitch_freqRange = c(80,250),\n             pitch_axisLabel = 'f0 (Hz)')\n\n\n\n\n\n\n\n\nThis will also work if pitch is ‘speckled’:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_plotOnSpec = TRUE,\n             pitch_plotType = 'speckle',\n             pitch_color = c('black', 'white'),\n             pitch_freqRange = c(80,250),\n             pitch_axisLabel = 'f0 (Hz)')"
  },
  {
    "objectID": "pitch.html#sec-pitch-wave-overlay",
    "href": "pitch.html#sec-pitch-wave-overlay",
    "title": "6  Pitch",
    "section": "6.2 Overlaying on waveform",
    "text": "6.2 Overlaying on waveform\nIt’s also possible to overlay pitch on the waveform. This works much the same as overlaying pitch on the spectrogram, controlled with the pitch_plotOnWave argument.\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(50,50),\n             wave_color = 'grey',\n             pitch_plotOnWave = TRUE)\n\n\n\n\n\n\n\n\nAs above, all the default pitch plotting parameters also apply when plotting pitch on a waveform:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(50,50),\n             wave_color = 'grey',\n             pitch_plotOnWave = TRUE,\n             pitch_color = c('black','white'),\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,250),\n             pitch_axisLabel = 'f0 (Hz)')"
  },
  {
    "objectID": "pitch.html#sec-pitch-praat",
    "href": "pitch.html#sec-pitch-praat",
    "title": "6  Pitch",
    "section": "6.3 Calculate using R or Praat?",
    "text": "6.3 Calculate using R or Praat?\nPitch tracks are typically calculated on the fly in R using the ksvF0() function from the wrassp library, which is a convenient way to call functions from the C library libassp in R. ksvF0() implements the pitch detection method described by Schäfer-Vincent (1983).\nThere are several reasons why you may wish to use the signal processing tools from Praat instead. For example, Praat has a nice GUI allowing users to hand-edit the pitch contour, and if you’re writing about pitch and using Praat to generate the pitch contours, it could be important to show actual examples of the data you’re analyzing using the exact same parameter settings as you’re using for the analysis. And in all likelihood the pitch detection method used by Praat (described by Boersma 1993) is more accurate than the one implemented in ksvF0(). Luckily, it’s fairly straightforward to plot pitch contours in praatpicture that are calculated in Praat.\nIf you open and select a sound file in Praat, you can generate a pitch track by clicking the Analyse periodicity - button and selecting one of the To Pitch... options. Once you have done this, and you’ve potentially edited the pitch track according to your wishes, click the Save button and Save as text file..., and save the object using the same base name as your sound file and the .Pitch extension. If you have done this, praatpicture will automatically plot the values in the .PitchTier file instead of calculating pitch on the fly. Alternatively, you can click the Convert - button and select Down to PitchTier, and save this as a text file with the .PitchTier extension. It typically does not matter whether you plot a Pitch or PitchTier object, but you may see some unwanted interpolation if you plot longer PitchTier objects with pitch_plotType = 'speckle'.\nAs an example, this is a copy of the file that we’ve used throughout this section, which has a corresponding .PitchTier file (i.e., pitch is generated in Praat):\n\npraatpicture('ex/ex_praatsp.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,250))\n\n\n\n\n\n\n\n\nAnd this is that same snippet with pitch generated in R on the fly:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,250))\n\n\n\n\n\n\n\n\nReasonably similar results, but the ksvF0() contour is sometimes a bit more jagged, and it detects a rise that Praat does not find!\nNote that the signal processing options introduced below are only used when calculating pitch on the fly in R. If pitch is plotted from a .PitchTier file, they are ignored – in this case, you need to set your own signal processing parameters in Praat!\nAs we will see in Section 15.3, any method can in principle be used for calculating the plotted pitch tracks as long as the results are formatted in a particular way."
  },
  {
    "objectID": "pitch.html#signal-processing",
    "href": "pitch.html#signal-processing",
    "title": "6  Pitch",
    "section": "6.4 Signal processing",
    "text": "6.4 Signal processing\nThe parameters used to predict pitch do not use ksvF0() defaults, but are rather set to emulate Praat as closely as possible. Some of these can’t be changed (using Gaussian-shaped KAISER2_0 windows), but some can! You’ll find that some of the settings which can be toggled in Praat are not necessarily available in praatpicture, either because ksvF0() doesn’t allow you to change them, or because these settings are specific to the pitch tracking algorihtm(s) used in Praat.\n\n6.4.1 Floor and ceiling\nThe lowest and highest pitch to look for is controlled with the pitch_floor and pitch_ceiling parameters. By default, praatpicture searches between 75–600 Hz, which is in most cases fine for plotting, but is worth limiting if you see octave jumps in the resulting plots.\nIncreasing the range to 50–800 Hz does not change much, but provides a slightly smoother contour (probably because the measurement interval depends on these settings; see below).\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_floor = 50,\n             pitch_ceiling = 800)\n\n\n\n\n\n\n\n\nWe’ll mostly see a change if we drastically reduce the range. Here I’ve set it to 100–200 Hz, i.e. a ceiling well below the higher range of this speaker. Here you’ll see that higher frequencies are missing:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_floor = 100,\n             pitch_ceiling = 200)\n\n\n\n\n\n\n\n\n\n\n6.4.2 Measurement interval\nThe intervals at which to measure pitch is controlled with the pitch_timeStep parameter. The default here is to calculate the measurement interval dynamically based on the pitch_floor, such that it is \\(\\frac{3}{4}\\) pitch_floor, which with the default floor of 75 Hz amounts to 0.01, i.e. every 10 ms. But users can also specify a number (in ms). Here we take a lot more measures, once per ms:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_timeStep = 0.001)\n\n\n\n\n\n\n\n\nAnd this is what it looks like with fewer measures, once every 50 ms:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_timeStep = 0.05)"
  },
  {
    "objectID": "formant.html#appearance",
    "href": "formant.html#appearance",
    "title": "7  Formants",
    "section": "7.1 Appearance",
    "text": "7.1 Appearance\n\n7.1.1 Plot type\nWhen plotting formants in Praat, formant tracks are either ‘drawn’ or ‘speckled’. The default is ‘speckled’, i.e. point plots:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey')\n\n\n\n\n\n\n\n\nThis can be controlled with the formant_plotType argument. A ‘drawn’ plot will produce a line plot:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_plotType = 'draw')\n\n\n\n\n\n\n\n\nThis will look really erratic for sequences of speech where there aren’t supposed to be any vowels, but looks alright when e.g. plotting a diphthong, as we can see if we plot just a portion of this sound:\n\npraatpicture('ex/fmt.wav',\n             start = 0.4, end = 0.85,\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_plotType = 'draw')\n\n\n\n\n\n\n\n\nIf you want to draw formant contours with thicker, you can set the drawSize argument larger than 1 (which will also affect other drawn derived signals, i.e. pitch or intensity).\n\npraatpicture('ex/fmt.wav',\n             start = 0.4, end = 0.85,\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_plotType = 'draw',\n             drawSize = 3)\n\n\n\n\n\n\n\n\nThe speckleSize argument works similarly if you want larger points in a speckled plot.\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             speckleSize = 2)\n\n\n\n\n\n\n\n\n\n\n7.1.2 Number of formants to plot\nThe formant_number argument controls how many formants to show. Here we plot only the first three formants:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_number = 3)\n\n\n\n\n\n\n\n\nNote that this is not the same as only estimating three formants, which is controlled with the formant_maxN argument as shown below. Changing formant_maxN will change the signal processing, while formant_number only controls how many formants are shown in the plot. You will get an error if formant_number is higher than formant_maxN.\n\n\n7.1.3 Frequency range\nThe default frequency range for formant plots shows between 50–5500 Hz. This is rather broad for most purposes. Frequency range can be controlled with the formant_freqRange argument. Here, a frequency range between 100–4000 Hz is probably more suitable:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_freqRange = c(100,4000))\n\n\n\n\n\n\n\n\n\n\n7.1.4 Dynamic range\nThe dynamic range of the formant track is set to 30 dB by default, meaning that only formant measures taken from windows of the sound file with energy within the highest 30 dB in the plotted sound snippet are rendered; at least in ‘speckled’ plots, all other measures are ignored. This can be controlled with the formant_dynamicRange argument.\nIn the plots above, it is clear that formants are sometimes included from portions of speech that aren’t actually vowels. If we reduce formant_dynamicRange, there’s a higher chance that formants are only plotted from vowels. Here shown with a dynamic range of just 8 dB:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_dynamicRange = 8)\n\n\n\n\n\n\n\n\nIf we increase the dynamic range, we’ll see that formants are being predicted all over the place. Here with a dynamic range of 50 dB:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_dynamicRange = 50)\n\n\n\n\n\n\n\n\n\n\n7.1.5 Coloring options\nThe color of the formant tracks can be controlled with the formant_color argument. Here are formants plotted in red:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_dynamicRange = 8,\n             formant_color = 'red')\n\n\n\n\n\n\n\n\nIt is possible to use different colors for different formant values, by passing a vector to formant_color with as many colors as the number of formants being plotted. This can help differentiate the different formants in more complex plots:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_dynamicRange = 8,\n             formant_color = c('red', 'blue', 'darkgreen', 'orange', 'purple'))\n\n\n\n\n\n\n\n\nSome fancier coloring options are available when formants are overlaid on spectrograms; more on that in Section 7.1.8.\n\n\n7.1.6 Axis label\nUsers can specify their own axis labels, using the formant_axisLabel argument. For example, we might want to specify that they are formants:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_dynamicRange = 8,\n             formant_axisLabel = 'Formants (Hz)')\n\n\n\n\n\n\n\n\n\n\n7.1.7 Horizontal dotted lines\nFollowing the Praat defaults for formant plotting, horizontal dotted lines are shown in formant plots at multiples of 1000 Hz. This is controlled with the general draw_lines argument, and you can override the default dotted lines by setting draw_lines to NULL:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_dynamicRange = 8,\n             draw_lines = NULL)\n\n\n\n\n\n\n\n\nMore on draw_lines in Section 9.3.\n\n\n7.1.8 Overlaying on spectrogram\nInstead of drawing formants in their own frame, it is also possible to overlay formants on a spectrogram. In this case, formant should not be specified as one of the frames; this is instead controlled with the Boolean formant_plotOnSpec argument.\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_plotOnSpec = TRUE)\n\n\n\n\n\n\n\n\nThe other arguments controlling formant appearance (and signal processing) also work when overlaying formants on the spectrogram. For example, we clearly see above that a dynamic range of 30 dB is too high for this file, and that 8 dB is more suitable. Also, formants overlaid on a spectrogram stand out much more if they are not plotted in black.\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_plotOnSpec = TRUE,\n             formant_dynamicRange = 8,\n             formant_color = 'red')\n\n\n\n\n\n\n\n\nWhen overlaying formants on a spectrogram, there is the added option of having a wider point with a separate background color, which helps the trace stand out more. For example, we may want the formants in the above plot to have a pink background color. In this case, we can pass a vector to pitch_color specifying first the main color, and then the background:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_plotOnSpec = TRUE,\n             formant_dynamicRange = 8,\n             formant_color = c('red', 'pink'))\n\n\n\n\n\n\n\n\nThis will also work when producing a ‘drawn’ plot:\n\npraatpicture('ex/fmt.wav',\n             start = 0.4, end = 0.9,\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_plotOnSpec = TRUE,\n             formant_plotType = 'draw',\n             formant_color = c('black', 'white'))\n\n\n\n\n\n\n\n\nIf you’re using different colors for different formants, you can pass a vector with one more color than the number of formants being plotted, and then the last one will be used for the background. Here with a light grey background:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_plotOnSpec = TRUE,\n             formant_dynamicRange = 8,\n             formant_color = c('red', 'blue', 'darkgreen', 'orange', 'purple',\n                               'lightgrey'))\n\n\n\n\n\n\n\n\nYou can also pass a vector with twice as many colors as the formants being plotted. In this case, the last half will be used for background colors:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_plotOnSpec = TRUE,\n             formant_dynamicRange = 8,\n             formant_color = c('red', 'blue', 'darkgreen', 'orange', 'purple',\n                               'pink', 'lightblue', 'green', 'yellow', \n                               'magenta'))"
  },
  {
    "objectID": "formant.html#sec-formant-praat",
    "href": "formant.html#sec-formant-praat",
    "title": "7  Formants",
    "section": "7.2 Calculate using R or Praat?",
    "text": "7.2 Calculate using R or Praat?\nFormants are typically calculated on the fly in R using the forest() function from the wrassp library, which is a convenient way to call functions from the C library libassp in R. forest() uses the split-Levinson algorithm to detect formants as implemented by Willems (1987).\nThere are several reasons why you may wish to use the signal processing tools from Praat instead. For example, if you’re writing about formants and using Praat to calculate the formants, it could be important to show actual examples of the data you’re analyzing using the exact same parameter settings as you’re using for the analysis. And in all likelihood the Burg algorithm that Praat uses for formant detection method is more accurate than the one implemented in forest(), as the Praat documentation specifically alludes to. Luckily, it’s fairly straightforward to plot formants in praatpicture that are calculated in Praat.\nIf you open and select a sound file in Praat, you can generate a formant track by clicking the Analyse spectrum - button and selecting one of the To Formant... options. Once you have done this, and you’ve potentially edited the formant track according to your wishes, click the Save button and select Save as text file..., and save the object using the same base name as your sound file and the .Formant extension. If you have done this, praatpicture will automatically plot the values in the .Formant file instead of calculating formants on the fly.\nAs an example, this is a copy of the file that we’ve used throughout this section, which has a corresponding .Formant file (i.e., formants are calculated in Praat):\n\npraatpicture('ex/fmt_praatsp.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_dynamicRange = 30)\n\n\n\n\n\n\n\n\nIn this particular case, the Praat-calculated formant tracks are in fact highly erratic, much more so than the forest()-calculated formants.\nNote that the signal processing options introduced below are only used when calculating formants on the fly in R. If formants are plotted from a .Formant file, they are ignored – in this case, you need to set your own signal processing parameters in Praat!\nAs we will see in Section 15.3, any method can in principle be used for calculating the plotted formants as long as the results are formatted in a particular way."
  },
  {
    "objectID": "formant.html#signal-processing",
    "href": "formant.html#signal-processing",
    "title": "7  Formants",
    "section": "7.3 Signal processing",
    "text": "7.3 Signal processing\nThe parameters used to predict formants do not use forest() defaults, but are rather set to emulate Praat as closely as possible. Some of these can’t be changed (using Gaussian-shaped KAISER2_0 windows), but some can! You’ll find that some of the settings which can be toggled in Praat are not necessarily available in praatpicture (unfortunately including a formant ceiling parameter setting a maximum search range), either because forest() doesn’t allow you to change them, or because these settings are specific to the formant tracking algorihtm(s) used in Praat.\n\n7.3.1 Window length\nUsers can control the effective length of windows in which to search for formants with the formant_windowLength argument. The default is 25 ms. If we reduce the size of this window to e.g. 5 ms, it does not clearly result in worse predictions for the lower formants, but the higher formants are clearly more poorly tracked.\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_dynamicRange = 8,\n             formant_windowLength = 0.005)\n\n\n\n\n\n\n\n\nThe algorithm seems less sensitive to increasing the window length, although this does increase the processing time and probably does not have many clear benefits. Here with a window length of 50 ms:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_dynamicRange = 8,\n             formant_windowLength = 0.05)\n\n\n\n\n\n\n\n\n\n\n7.3.2 Measurement interval\nThe intervals a which to measure formants is controlled with the formant_timeStep parameter. The default here is to calculate the measurement interval dynamically calculated based on the formant_windowLength, such that it is \\(\\frac{1}{4}\\) formant_windowLength, which with the default window length of 25 ms amounts to 0.00625, i.e. every 6.25 ms. But users can also specify a number (in ms). Here we take a lot more measures, once per ms:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_dynamicRange = 8,\n             formant_timeStep = 0.001)\n\n\n\n\n\n\n\n\nAnd this is what it looks like with fewer measures, once every 25 ms:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_dynamicRange = 8,\n             formant_timeStep = 0.025)\n\n\n\n\n\n\n\n\n\n\n7.3.3 Number of formants to estimate\nYou might think that the estimated number of formants is primarily an appearance parameter, but in fact the number of formants estimated can affect the overall results a fair bit. The number of formants to estimate is controlled with the formant_maxN parameter, which is by default set to 5. For this particular sound file, reducing the number of formants to 3 does not change the estimation of those 3 formants much:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_dynamicRange = 8,\n             formant_maxN = 3)\n\n\n\n\n\n\n\n\nWe could also set the number higher. Here, we estimate 8 formants:\n\npraatpicture('ex/fmt.wav',\n             frames = c('sound', 'formant'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             formant_dynamicRange = 8,\n             formant_freqRange = c(0,8000),\n             formant_maxN = 8)\n\n\n\n\n\n\n\n\nThis could be useful, but you’ll note that the algorithm is less effective for higher formants."
  },
  {
    "objectID": "intensity.html#apperance",
    "href": "intensity.html#apperance",
    "title": "8  Intensity",
    "section": "8.1 Apperance",
    "text": "8.1 Apperance\n\n8.1.1 Range\nBy default, the amplitude range for intensity plots is dynamically determined to show the entire contour. The amplitude range can be controlled with the intensity_range argument. Here, we show 0–80 dB:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'intensity'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             intensity_range = c(0,80))\n\n\n\n\n\n\n\n\n\n\n8.1.2 Coloring options\nThe color of the intensity contour is controlled with the intensity_color argument. Here’s a dark green contour:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'intensity'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             intensity_color = 'darkgreen')\n\n\n\n\n\n\n\n\nSome fancier coloring options are available when an intensity contour is overlaid on spectrograms; more on that in Section 8.1.5.\n\n\n8.1.3 Axis label\nUsers can specify their own axis labels, using the intensity_axisLabel argument. For example, we might want to use the term ‘root-mean-squared amplitude’, which is often used instead of ‘intensity’:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'intensity'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             intensity_axisLabel = 'Root-mean-squared amplitude (dB)')\n\n\n\n\n\n\n\n\n\n\n8.1.4 Line width\nIf you want to draw intensity contours with thicker, you can set the drawSize argument larger than 1 (which will also affect other drawn derived signals, i.e. pitch or formants).\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'intensity'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             drawSize = 3)\n\n\n\n\n\n\n\n\n\n\n8.1.5 Overlaying on spectrogram\nInstead of drawing intensity in its own frame, it is also possible to overlay an intensity contour on a spectrogram. In this case, intensity should not be specified as one of the frames; this is instead controlled with the Boolean intensity_plotOnSpec argument.\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             intensity_plotOnSpec = TRUE)\n\n\n\n\n\n\n\n\nThe other arguments controlling intensity appearance (and signal processing) also work when overlaying intensity on the spectrogram:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             intensity_plotOnSpec = TRUE,\n             intensity_range = c(0, 80),\n             intensity_color = 'darkgreen',\n             intensity_axisLabel = 'Root-mean-squared amplitude (dB)')\n\n\n\n\n\n\n\n\nNotice that the y-axis label will match the color of the intensity contour.\nWhen overlaying an intensity contour on a spectrogram, there is the added option of having a wider line with a separate background color, which helps the contour stand out more. For example, we may want the intensity contour in the above plot to have a lighter green background color. In this case, we can pass a vector to intensity_color specifying first the main color, and then the background:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             intensity_plotOnSpec = TRUE,\n             intensity_color = c('darkgreen', 'green'))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMultiple spectrogram overlays, multiple signals in one frame\n\n\n\nAs you may have noticed, it’s possible to add either intensity, formants, or pitch traces on the spectrogram using the three separate arguments intensity_plotOnSpec, formant_plotOnSpec, and pitch_plotOnSpec. These do not cancel each other out; although it’s probably not recommended to do so – it makes for a very busy plot – you can choose to overlay all three on one spectrogram:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             intensity_plotOnSpec = TRUE,\n             intensity_color = c('darkgreen', 'green'),\n             formant_plotOnSpec = TRUE,\n             formant_color = c('red', 'pink'),\n             pitch_plotOnSpec = TRUE,\n             pitch_color = c('blue', 'lightblue'))\n\n\n\n\n\n\n\n\nIf you want multiple signals in one frame but don’t actually want the spectrogram, there’s a hack to do so: if you set the dynamic range of the spectrogram to 0 dB, it will simply be rendered as white, and if you then overlay other derived signals on the “spectrogram”, you will see just the other derived signals:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             intensity_plotOnSpec = TRUE,\n             intensity_color = c('darkgreen', 'green'),\n             formant_plotOnSpec = TRUE,\n             formant_color = c('red', 'pink'),\n             pitch_plotOnSpec = TRUE,\n             pitch_color = c('blue', 'lightblue'),\n             spec_dynamicRange = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n8.1.6 Overlaying on waveform\nIntensity can also be overlaid on the waveform. This is controlled using the intensity_plotOnWave argument.\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(50,50),\n             wave_color = 'grey',\n             intensity_plotOnWave = TRUE)\n\n\n\n\n\n\n\n\nAs with spectrogram overlays, all the other arguments controlling intensity appearance can still be controlled in the usual way:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'spectrogram'),\n             proportion = c(50,50),\n             wave_color = 'grey',\n             intensity_plotOnWave = TRUE,\n             intensity_range = c(0, 80),\n             intensity_color = c('darkgreen','green'),\n             intensity_axisLabel = 'Root-mean-squared amplitude (dB)')"
  },
  {
    "objectID": "intensity.html#sec-intensity-praat",
    "href": "intensity.html#sec-intensity-praat",
    "title": "8  Intensity",
    "section": "8.2 Calculate using R or Praat?",
    "text": "8.2 Calculate using R or Praat?\nIntensity contours are typically calculated on the fly in R using the rmsana() function from the wrassp library, which is a convenient way to call functions from the C library libassp in R. rmsana() should in theory be implementing the same algorithm as Praat, but there will be some slight differences.\nThere are several reasons why you may wish to use the signal processing tools from Praat instead. If you’re writing about intensity and using Praat to generate the intensity contours, it could be important to show actual examples of the data you’re analyzing using the exact same parameter settings and the exact same algorithm as you’re using for the analysis. Luckily, it’s fairly straightforward to plot intensity contours in praatpicture that are calculated in Praat.\nIf you open and select a sound file in Praat, you can generate an intensity contour by clicking the To Intensity... button. Once you have done this, select the resulting Intensity object, and click the Down to IntensityTier button. Select this IntensityTier object, click the Save button, and select Save as text file..., and save the object using the same base name as your sound file and the .IntensityTier extension. If you have done this, praatpicture will automatically plot the values in the .IntensityTier file instead of calculating intensity on the fly.\nAs an example, this is a copy of the file that we’ve used throughout this section, which has a corresponding .IntensityTier file (i.e., intensity is calculated in Praat):\n\npraatpicture('ex/ex_praatsp.wav',\n             frames = c('sound', 'intensity'),\n             proportion = c(30,70),\n             wave_color = 'grey')\n\n\n\n\n\n\n\n\nAnd this is that same snippet with intensity calculated in R on the fly:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'intensity'),\n             proportion = c(30,70),\n             wave_color = 'grey')\n\n\n\n\n\n\n\n\nFor most purposes, the intensity calculated on the fly in R will do just fine – there are only very slight differences in the resulting contour shapes.\nNote that the signal processing options introduced below are only used when calculating intensity on the fly in R. If intensity is plotted from an .IntensityTier file, they are ignored – in this case, you need to set your own signal processing parameters in Praat!"
  },
  {
    "objectID": "intensity.html#signal-processing",
    "href": "intensity.html#signal-processing",
    "title": "8  Intensity",
    "section": "8.3 Signal processing",
    "text": "8.3 Signal processing\nThe parameters used to predict pitch do not use rmsana() defaults, but are rather set to emulate Praat as closely as possible. Some of these can’t be changed (using Gaussian-shaped KAISER2_0 windows), but some can, in this case the same as those that can be toggled in Praat!\n\n8.3.1 Minimum pitch\nThe default is to assume a minimum pitch of 100 Hz. That’s probably a bit high for this speaker, who does sometimes have pitch values below 100 Hz. With a minimum pitch of 50 Hz, we get smaller excursions:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'intensity'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             intensity_minPitch = 50)\n\n\n\n\n\n\n\n\nIf we set minimum pitch too high, we get a very jagged contour:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'intensity'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             intensity_minPitch = 200)\n\n\n\n\n\n\n\n\n\n\n8.3.2 Measurement interval\nThe intervals at which to measure intensity is controlled with the intensity_timeStep parameter. The default here is to calculate the measurement interval dynamically based on the intensity_minPitch, such that it is \\(\\frac{4}{5}\\) / intensity_minPitch, which with the default minimum pitch of 100 Hz amounts to 0.008, i.e. every 80 ms. But users can also specify a number (in ms). Here we take a lot more measures, once per ms:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'intensity'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             intensity_timeStep = 0.001)\n\n\n\n\n\n\n\n\nAnd this is what it looks like with fewer measures, once every 25 ms:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'intensity'),\n             proportion = c(30,70),\n             wave_color = 'grey',\n             intensity_timeStep = 0.025)"
  },
  {
    "objectID": "highlight.html#arrows",
    "href": "highlight.html#arrows",
    "title": "9  Highlighting plot areas",
    "section": "9.1 Arrows",
    "text": "9.1 Arrows\nPerhaps you’ve plotted a picture of a short sentence, like this, containing a waveform, speckled pitch contour, spectrogram, and annotations:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word')\n\n\n\n\n\n\n\n\nYou may want to add an arrow to this plot indicating the position of the peak in the pitch contour. This can be achieved with the draw_arrow argument. This argument should consist of a vector with the following structure:\n\nthe name of the plot component to add the arrow to (in this case pitch);\nand arguments for drawing an arrow which are then passed down to the arrows function. You can see what these arguments are by typing help(arrows).\n\nThe most important arguments to draw_arrow are the coordinate space: Where should the arrow start on the x-axis, where should it start on the y-axis, where should it end on the x-axis, and where should it end on the y-axis?\nIn our pitch peak case, we may want to start at 0.8 seconds and 100 Hz, and end at 0.65 seconds and 200 Hz. This gives the following result:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_arrow = c('pitch', 0.8, 100, 0.65, 200))\n\n\n\n\n\n\n\n\nOther arguments to draw_arrow include length, i.e. the length of the arrow head. It’s set to 0.25 inches by default, here we may want to shorten it somewhat:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_arrow = c('pitch', 0.8, 100, 0.65, 200, length = 0.15))\n\n\n\n\n\n\n\n\nAnother important argument is angle, determining the angle of the arrow head. The default is set to 30 degrees, which we may want to reduce a little:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_arrow = c('pitch', 0.8, 100, 0.65, 200, length = 0.15,\n                            angle = 20))\n\n\n\n\n\n\n\n\nThe code argument determines which way the arrow is pointing; code = 3 will produce a double-headed arrow. Here’s a plot with a double headed arrow showing the gap in pitch tracking the word “laksen”:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_arrow = c('pitch', 0.82, 170, 0.67, 220, length = 0.15,\n                            angle = 20, code = 3))\n\n\n\n\n\n\n\n\nIt can take a bit of fiddling to get the coordinates just right, but at least the plots are produced quickly!\ndraw_arrow also understands other “classical” base R graphics parameters, such as col for color, lty for line type, and lwd for line width. This would be how to plot a thicker, dotted blue line covering the length of the spectrogram:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_arrow = c('spectrogram', 0, 2500, 1.8, 2500, code = 3,\n                            col = 'blue', lwd = 3, lty = 'dotted'))\n\n\n\n\n\n\n\n\nYou can add as many arrows as you want to a plot. If you want to add multiple arrows, you just have to pass a list containing multiple arrows with their own separate arguments to draw_arrow. In this plot, we’ve overlaid color coded formants on the spectrogram, and we want to have arrows of matching colors pointing to the formant offsets in the first syllable in “laksen”, in addition to our ‘pitch peak’ arrow from above:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             formant_plotOnSpec = TRUE,\n             formant_maxN = 3,\n             formant_dynamicRange = 13,\n             formant_color = c('red', 'blue', 'orange'),\n             tg_tiers = 'word',\n             draw_arrow = list(\n               c('pitch', 0.8, 100, 0.65, 200, length = 0.15, angle = 20),\n               c('spectrogram', 0.8, 750, 0.65, 750, length = 0.15, \n                 angle = 20, col = 'red'),\n               c('spectrogram', 0.8, 1550, 0.65, 1550, length = 0.15, \n                 angle = 20, col = 'blue'),\n               c('spectrogram', 0.8, 2200, 0.65, 2200, length = 0.15, \n                 angle = 20, col = 'orange')))"
  },
  {
    "objectID": "highlight.html#rectangles",
    "href": "highlight.html#rectangles",
    "title": "9  Highlighting plot areas",
    "section": "9.2 Rectangles",
    "text": "9.2 Rectangles\nYou can draw rectangles on plot components using the draw_rectangle argument. The argument structure is similar to draw_arrow:\n\nthe name of the plot component to add the rectangle to;\nand arguments for drawing a rectangle which are then passed down to the rect function. You can see what these arguments are by typing help(rect).\n\nThe most important arguments to draw_rectangle are the coordinate space: What is the leftmost point on the x-axis, what is the bottom point on the y-axis, what is the rightmost point on the x-axis, and what is the top part on the y-axis? Arguments are presented in this order.\nUsing the same sound snippet we’ve seen above, perhaps we want to add a rectangle around the pitch contour of the second syllable of the word laksen. In this case, we want the beginning of the rectangle at 0.8 seconds, the lowest point at 85 Hz, the end at 0.98 seconds, and the highest point at 200 Hz, like so:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_rectangle = c('pitch', 0.8, 85, 0.98, 200))\n\n\n\n\n\n\n\n\nOther arguments which can be passed to draw_rectangle include col which determines the fill color. If we want to “hide” this part of the pitch contour, we could draw it with white fill:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_rectangle = c('pitch', 0.8, 85, 0.98, 200, col = 'white'))\n\n\n\n\n\n\n\n\nChanging the line color is controlled with the argument border. Here we see it in blue:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_rectangle = c('pitch', 0.8, 85, 0.98, 200, \n                                border = 'blue'))\n\n\n\n\n\n\n\n\nThe line type is controlled with the lty argument. Here we see a rectangle with dashed lines:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_rectangle = c('pitch', 0.8, 85, 0.98, 200, lty = 'dashed'))\n\n\n\n\n\n\n\n\nAnd line width is controlled with the lwd argument, here a version with thicker lines:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_rectangle = c('pitch', 0.8, 85, 0.98, 200, lwd = 3))\n\n\n\n\n\n\n\n\nAs is the case with arrows, you can add as many rectangles as you want to a plot. If you want to add multiple rectangles, you just have to pass a list containing multiple rectangles with their own separate arguments to draw_rectangle. Here, we draw rectangles with white fill around both the wave and the pitch track in the second syllable of the word laksen, and we draw slightly thicker rectangles with red and blue outlines respectively around the first and two formants in the spectrogram of the word valgte:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_rectangle = list(\n               c('pitch', 0.8, 85, 0.98, 200, col = 'white'),\n               c('sound', 0.8, -0.15, 0.98, 0.15, col = 'white'),\n               c('spectrogram', 0.1, 200, 0.25, 800, border = 'red', lwd = 2),\n               c('spectrogram', 0.1, 1300, 0.25, 1900, border = 'blue', \n                 lwd = 2)))\n\n\n\n\n\n\n\n\nThere are a few other options that can be passed to draw_rectangle which aren’t covered here; see help(rect) if you’re interested."
  },
  {
    "objectID": "highlight.html#sec-lines",
    "href": "highlight.html#sec-lines",
    "title": "9  Highlighting plot areas",
    "section": "9.3 Straight lines",
    "text": "9.3 Straight lines\nIn addition to arrows and rectangles, the argument draw_lines allows you to add one or more straight lines to a plot. The structure of draw_lines arguments is a little different from draw_rectangle and draw_arrow, but mostly in the sense that it has to be a list instead of a vector (i.e. list() and not c()). The first element of the list should be the plot component to draw on, and other elements are arguments to be passed to the abline() function. See help(abline) for more information about this.\nIn the figure that we’ve seen previously, we could add a horizontal line at 2,500 Hz in the spectrogram by passing h = 2500, like so:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_lines = list('spectrogram', h = 2500))\n\n\n\n\n\n\n\n\nWe could draw a vertical line 0.5 seconds in by passing v = 1.6:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_lines = list('spectrogram', v = 1.6))\n\n\n\n\n\n\n\n\nYou can also in theory add a regression line by specifying an intercept a and slope b. Here with an intercept of 250 Hz and 2,500 Hz:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_lines = list('spectrogram', a = 250, b = 2500))\n\n\n\n\n\n\n\n\nAs with lines and rectangles, we can control color with the col argument, line type with the lty argument, and line width with the lwd argument. Here I repeat the previous plot with a thick, red dashed line:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_lines = list('spectrogram', a = 250, b = 2500,\n                               col = 'red', lty = 'dashed', lwd = 3))\n\n\n\n\n\n\n\n\nIf you’ve ever plotted formants on their own using praatpicture, you will have seen the draw_lines argument in use before see 7.1.7:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'formant', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word')\n\n\n\n\n\n\n\n\nFormant plots show horizontal dotted lines at multiples of 1,000 Hz. This is because the default value for draw_lines is list('formant', h = seq(0, 10000, by = 1000), lty = 'dotted'). Let’s unpack this. The h argument indicates that the lines should be horizontal, and instead of passing a single argument to his we pass a vector made with the seq() function. seq(0, 10000, by = 1000) returns the following vector:\n\nseq(0, 10000, by = 1000)\n\n [1]     0  1000  2000  3000  4000  5000  6000  7000  8000  9000 10000\n\n\nIn the same manner, we could add blue dashed lines at multiples of 500 Hz to our spectrogram:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_lines = list('spectrogram',\n                               h = seq(0, 5000, by = 500),\n                               col = 'blue', lty = 'dashed'))\n\n\n\n\n\n\n\n\nIf you don’t plot a TextGrid, or wish to add vertical lines to just one plot component, this is also the way to do it. Here we add straight lines between each of the syllables on the pitch contour:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram'),\n             proportion = c(20,30,50),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_lines = list('pitch', \n                               v = c(0.35, 0.75, 1, 1.25, 1.55)))\n\n\n\n\n\n\n\n\nIf we want to add more sets of lines with different parameters, we can also do this, by passing a list consisting of multiple lists. Here we combine our two last plots:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram'),\n             proportion = c(20,30,50),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_lines = list(\n               list('pitch', v = c(0.35, 0.75, 1, 1.25, 1.55)),\n               list('spectrogram', h = seq(0, 5000, by = 500),\n                    col = 'blue', lty = 'dashed')))"
  },
  {
    "objectID": "highlight.html#text",
    "href": "highlight.html#text",
    "title": "9  Highlighting plot areas",
    "section": "9.4 Text",
    "text": "9.4 Text\nYou may want to add some text to a plot apart from the annotations found in a TextGrid. You can do this with the annotate argument. This argument should consist of a vector with the following structure:\n\nthe name of the plot component to annotate;\nand arguments for annotating which are then passed down to the text function. You can see what these arguments are by typing help(text).\n\nThe most important arguments to annotate are the the coordinate space and the text to include. Where should the text be placed on the x-axis and where should it be placed on the y-axis? The coordinate space is controlled with the x and y arguments, and the text is controlled with the labels argument.\nAbove, we made a plot with an arrow pointing towards the peak on the pitch contour. We may want to add a label to this plot saying “peak”. This can be done like so:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_arrow = c('pitch', 0.8, 100, 0.65, 200, length = 0.15),\n             annotate = c('pitch', 0.8, 250, labels = 'pitch peak'))\n\n\n\n\n\n\n\n\nThe color of the text labels can be controlled with the col argument. Here is the same label in red:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_arrow = c('pitch', 0.8, 100, 0.65, 200, length = 0.15),\n             annotate = c('pitch', 0.8, 250, labels = 'pitch peak',\n                          col = 'red'))\n\n\n\n\n\n\n\n\nThe font argument can be used to control the font type, with 2 corresponding to bold, 3 corresponding to italics, and 4 corresponding to bold italics. Here’s the same plot as above using a bold-face font:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             draw_arrow = c('pitch', 0.8, 100, 0.65, 200, length = 0.15),\n             annotate = c('pitch', 0.8, 250, labels = 'pitch peak',\n                          col = 'red', font = 2))\n\n\n\n\n\n\n\n\nThe cex argument can be used to control the font size of these annotations. Here’s a very large label on the spectrogram:\n\npraatpicture('ex/ex.wav',\n             frames = c('sound', 'pitch', 'spectrogram', 'TextGrid'),\n             proportion = c(20,20,50,10),\n             wave_color = 'grey',\n             pitch_plotType = 'speckle',\n             pitch_freqRange = c(80,300),\n             tg_tiers = 'word',\n             annotate = c('spectrogram', 0.8, 2500, labels = 'HUGE',\n                          col = 'red', font = 2, cex = 10))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nChanging the font size and type of this type of annotation is only possible if you have the latest development version of praatpicture installed."
  },
  {
    "objectID": "highlight.html#highlighting-multichannel-audio-data",
    "href": "highlight.html#highlighting-multichannel-audio-data",
    "title": "9  Highlighting plot areas",
    "section": "9.5 Highlighting multichannel audio data",
    "text": "9.5 Highlighting multichannel audio data\nIf you have data with multiple channels and you want to highlight just one of those channels, instead of writing sound as the first part of the highlighting argument, you can write the number of the channel instead. Here, we add an arrow to the third signal and write some text on the fourth signal:\n\npraatpicture('ex/multichannel.wav',\n             start = 0.6, end = 2.4,\n             frames = c('sound', 'TextGrid'),\n             proportion = c(70, 30),\n             draw_arrow = c(3, 0.05, 0.22, 0.2, 0.22, col = 'red',\n                            length = 0.15, angle = 20),\n             annotate = c(4, 0.22, 0.8, 'VOICING', font = 2))"
  },
  {
    "objectID": "par.html#global-font-size",
    "href": "par.html#global-font-size",
    "title": "10  Base R graphics options",
    "section": "10.1 Global font size",
    "text": "10.1 Global font size\nYou may be used to using the cex arguments (including cex.main, cex.axis etc) to control font size in base R plots. These mostly aren’t available to praatpicture for various reasons, mostly because they’re being used internally by the praatpicture-functions, but you can use the ps argument (short for point size) to control font size globally.\nHere’s a plot with ps = 18, a fairly large font size:\n\npraatpicture('ex/ex.wav', \n             ps = 18)\n\n\n\n\n\n\n\n\nAnd here’s one with ps = 6, a very small font size:\n\npraatpicture('ex/ex.wav', \n             ps = 6)"
  },
  {
    "objectID": "par.html#global-coloring-options",
    "href": "par.html#global-coloring-options",
    "title": "10  Base R graphics options",
    "section": "10.2 Global coloring options",
    "text": "10.2 Global coloring options\nWe’ve already seen that you have great flexibility with coloring of various elements in praatpicture. There are also some global coloring options available. For example, the bg argument controls the background color. For the Praat feeling, you could set it to pink:\n\npraatpicture('ex/ex.wav', \n             bg = 'pink')\n\n\n\n\n\n\n\n\nThis will not affect the “background color” of spectrograms associated with low energy regions, but you can always control that with the spec_color argument:\n\npraatpicture('ex/ex.wav', \n             bg = 'pink',\n             spec_color = c('pink', 'black'))\n\n\n\n\n\n\n\n\nYou can also use the col argument. Usually, this changes the color of mostly everything in a plot globally, but in this case it only changes the color of things that aren’t user controlled (mainly axis labels and boxes). Here is a plot with col = 'blue':\n\npraatpicture('ex/ex.wav', \n             col = 'blue')\n\n\n\n\n\n\n\n\nThe color of axis numbers is controlled with the col.axis argument:\n\npraatpicture('ex/ex.wav', \n             col = 'blue',\n             col.axis = 'blue')\n\n\n\n\n\n\n\n\nIf you want everything to be blue, you have to manually set all color values:\n\npraatpicture('ex/ex.wav', \n             col = 'blue',\n             col.axis = 'blue',\n             wave_color = 'blue',\n             spec_color = c('white', 'blue'),\n             tg_color = 'blue',\n             tg_focusTierColor = 'blue')\n\n\n\n\n\n\n\n\nA potentially useful consequence of this is the ability to make “dark mode” pictures, by setting the background color to black and all other colors to white:\n\npraatpicture('ex/ex.wav', \n             bg = 'black',\n             col = 'white',\n             col.axis = 'white',\n             wave_color = 'white',\n             spec_color = c('black', 'white'),\n             tg_color = 'white',\n             tg_focusTierColor = 'white')"
  },
  {
    "objectID": "par.html#fonts-and-font-families",
    "href": "par.html#fonts-and-font-families",
    "title": "10  Base R graphics options",
    "section": "10.3 Fonts and font families",
    "text": "10.3 Fonts and font families\nThe font argument controls the face of the font in text. If you want everything to be boldface, you can set font (and font.axis) to 2:\n\npraatpicture('ex/ex.wav', \n             font = 2,\n             font.axis = 2)\n\n\n\n\n\n\n\n\nA font value of 3 will produce italics:\n\npraatpicture('ex/ex.wav', \n             font = 3,\n             font.axis = 3)\n\n\n\n\n\n\n\n\nThe family argument globally controls the font family. There are a few different ones available to R. For more of a Praat feeling, you can use a serif font:\n\npraatpicture('ex/ex.wav', \n             family = 'serif')\n\n\n\n\n\n\n\n\nIf you use the extrafont library, you can use specify any font available on your computer. This is nice if for example you want to publish in Glossa or Laboratory Phonology, and you want your plots to use the same font as the article text:\n\nlibrary(extrafont)\n\nRegistering fonts with R\n\npraatpicture('ex/ex.wav', \n             family = 'Charis SIL')"
  },
  {
    "objectID": "par.html#line-widths",
    "href": "par.html#line-widths",
    "title": "10  Base R graphics options",
    "section": "10.4 Line widths",
    "text": "10.4 Line widths\nThe lwd arguments can be used to control line widths globally. You can use this to produce a plot that really stands out.\n\npraatpicture('ex/ex.wav', \n             lwd = 2)\n\n\n\n\n\n\n\n\nThe lty argument controls the global line type. You could use this if you wanted, say, dashed lines for all plot elements (although you probably don’t want this!)"
  },
  {
    "objectID": "par.html#saving-plots",
    "href": "par.html#saving-plots",
    "title": "10  Base R graphics options",
    "section": "10.5 Saving plots",
    "text": "10.5 Saving plots\nYou can save plots however you usually like to do this. If you use RStudio, you can use the Export function from the plotting window in the GUI, although my recommendation would be not to do so – plots created in this way typically don’t look very nice. You can also use png(), pdf(), tiff(), and related functions to your heart’s content."
  },
  {
    "objectID": "slice.html#appearance",
    "href": "slice.html#appearance",
    "title": "11  Spectral slices",
    "section": "11.1 Appearance",
    "text": "11.1 Appearance\n\n11.1.1 The basic call\ndraw_spectralslice() takes only two obligatory arguments: sound, specifying a sound file with the .wav extension, and time, which is the specific time point where you’re interested in taking the slice from. Here we draw a spectral slice taken from an [h]:\n\ndraw_spectralslice('ex/index.wav', time = 1)\n\n\n\n\n\n\n\n\n\n\n11.1.2 Axes\nFollowing Praat defaults, the plot above shows the entire frequency range of the sound file up to the Nyquist frequency. This is often not suitable – I’d wager phoneticians are rarely interested in frequencies above 12 kHz. In the sound. This can be changed with the freqRange argument, which gives should be both the minimum and maximum frequency desired:\n\ndraw_spectralslice('ex/index.wav', time = 1, \n                   freqRange = c(0, 12000))\n\n\n\n\n\n\n\n\nIt may make more sense to keep the entire frequency range if you plot them in a log scale, which can be done with the log argument:\n\ndraw_spectralslice('ex/index.wav', time = 1, \n                   log = TRUE)\n\n\n\n\n\n\n\n\nThe range of the y-axis is suitable enough in these plots, but you may not always find that this is the case. For example, this spectrum comes from an [s]:\n\ndraw_spectralslice('ex/ex.wav', time = 0.78, \n                   freqRange = c(0, 10000))\n\n\n\n\n\n\n\n\nThis spectrum looks flat to an extent that may be unsuitable. We can change the y-axis with the energyAxis argument. This is set to 60 by default, which gives a dynamic range of 60 dB/Hz, i.e. the minimum is set to 60 dB/Hz lower than the maximum. We can change this like so:\n\ndraw_spectralslice('ex/ex.wav', time = 0.78, \n                   freqRange = c(0, 10000), \n                   energyRange = 30)\n\n\n\n\n\n\n\n\nIf you want to set the exact limits of the energy range, you can do it by passing a vector with two numbers:\n\ndraw_spectralslice('ex/ex.wav', time = 0.78, \n                   freqRange = c(0, 10000), \n                   energyRange = c(-20, 20))\n\n\n\n\n\n\n\n\nAxis labels can be set with the freq_axisLabel and energy_axisLabel arguments. On the off change that you are preparing a paper in Danish, for example, you can choose to translate them:\n\ndraw_spectralslice('ex/ex.wav', time = 0.78, \n                   freqRange = c(0, 10000), \n                   energyRange = c(-20, 20),\n                   freq_axisLabel = 'Frekvens (Hz)',\n                   energy_axisLabel = 'Lydtryk (dB/Hz)')\n\n\n\n\n\n\n\n\n\n\n11.1.3 General apperance\nAs in praatpicture(), you can add a title to your plot and control its vertical alignment with the mainTitle and mainTitleAlignment arguments:\n\ndraw_spectralslice('ex/ex.wav', time = 0.78, \n                   freqRange = c(0, 10000), \n                   energyRange = c(-20, 20),\n                   mainTitle = 'An [s] spectrum',\n                   mainTitleAlignment = 0.5)\n\n\n\n\n\n\n\n\nThere are also arguments to control the color and lineWidth of the spectrum.\n\ndraw_spectralslice('ex/ex.wav', time = 0.78, \n                   freqRange = c(0, 10000), \n                   energyRange = c(-20, 20),\n                   color = 'blue',\n                   lineWidth = 2)\n\n\n\n\n\n\n\n\nSimilar to what we saw in Chapter 10, it is also possible use base R graphics parameters such as ps (for font size), bg (for background), and family (for font type) etc to change the apperance of the plot:\n\ndraw_spectralslice('ex/ex.wav', time = 0.78, \n                   freqRange = c(0, 10000), \n                   energyRange = c(-20, 20),\n                   bg = 'pink', ps = 18, family = 'serif')"
  },
  {
    "objectID": "slice.html#signal-processing",
    "href": "slice.html#signal-processing",
    "title": "11  Spectral slices",
    "section": "11.2 Signal processing",
    "text": "11.2 Signal processing\n\n11.2.1 Windows\nA spectral slice is of course never instantaneous, but is taken from a window around the time point specified with time. The length of this window can be set with windowLength, where the default (as when plotting a spectrogram) is 5 ms, i.e. a “regular” narrowband spectrum. To plot a broadband spectrum, you can set this to 30 ms instead. This is useful for inspecting individual harmonics, as done below in an [a].\n\ndraw_spectralslice('ex/index.wav', time = 0.8, \n                   freqRange = c(0, 5000),\n                   windowLength = 0.03)\n\n\n\n\n\n\n\n\nCompare this with a narrowband spectrum, where individual harmonics are much less visible:\n\ndraw_spectralslice('ex/index.wav', time = 0.8, \n                   freqRange = c(0, 5000),\n                   windowLength = 0.005)\n\n\n\n\n\n\n\n\nYou can also choose between a number of window shapes using the windowLength parameter. These were covered in much more detail in Chapter 5.\n\n\n11.2.2 Estimation method\nSpectra are by default estimated using the fast (discrete) Fourier transform, but praatpicture also allows for estimating spectra using the multitaper method. This is not an option in Praat, but they are fairly popular particularly for analyzing noisy obstruent sounds, since they dispense with the assumption of periodicity. For more on multitaper spectral analysis, see here.\nThis is the [s] we saw earlier with a spectrum analyzed using the multitaper method:\n\ndraw_spectralslice('ex/ex.wav', time = 0.78, \n                   freqRange = c(0, 10000),\n                   energyRange = 40,\n                   method = 'multitaper')\n\n\n\n\n\n\n\n\nYou will notice that this line is much less jagged.\nThe arguments windowLength and windowShape do not really apply to multitaper spectra, but there are a number of other parameters that can be set with the multitaper_args parameter. This accepts a named list which is then passed on to multitaper::spec.mtm(), the function that is used for estimating the spectrum."
  },
  {
    "objectID": "slice.html#highlighting",
    "href": "slice.html#highlighting",
    "title": "11  Spectral slices",
    "section": "11.3 Highlighting",
    "text": "11.3 Highlighting\ndraw_spectralslice() offers similar options for highlighting as praatpicture(): adding arrows, lines, rectangles, text, and delineated background colors. The arguments are similar: a named list is passed to either of the arguments draw_arrow, draw_lines, draw_rectangle, annotate and highlight.\nTo give a gist of how it works, here we highlight the second harmonic in the broadband spectrum we saw earlier using text and an arrow:\n\ndraw_spectralslice('ex/index.wav', time = 0.8, \n                   freqRange = c(0, 5000),\n                   windowLength = 0.03,\n                   draw_arrow = list(x0 = 300, y0 = 30, y1 = 19, \n                                     angle = 15, length = 0.15),\n                   annotate = list(x = 150, y = 24.5, labels = 'H2'))\n\n\n\n\n\n\n\n\nNote that you can also add more arrows or annotations to a single plot. Individual plotting arguments can be vector or the lists can be nested. Here we add arrows pointing to both the second and the fourth harmonic by setting the x0 argument with a vector\n\ndraw_spectralslice('ex/index.wav', time = 0.8, \n                   freqRange = c(0, 5000),\n                   windowLength = 0.03,\n                   draw_arrow = list(x0 = c(300, 600), y0 = 30, y1 = 19, \n                                     angle = 15, length = 0.15))\n\n\n\n\n\n\n\n\nWe can highlight parts of the spectrum with the highlight argument, which allows part of the spectrum to stand out in terms of line color, line width, and background color. Here, we do this to make the first four harmonics of the previous plot stand out:\n\ndraw_spectralslice('ex/index.wav', time = 0.8, \n                   freqRange = c(0, 5000),\n                   windowLength = 0.03,\n                   highlight = list(start = 80, end = 650,\n                                    background = 'lightblue',\n                                    color = 'red', drawSize = 2))"
  },
  {
    "objectID": "make_TextGrid.html#basic-usage",
    "href": "make_TextGrid.html#basic-usage",
    "title": "12  Annotating interactively in R",
    "section": "12.1 Basic usage",
    "text": "12.1 Basic usage\nThe make_TextGrid function takes two obligatory arguments:\n\nsound the name of a sound file to annotate\ntierNames the names of desired annotation tiers\n\nIf we run the following code, two things should happen: for RStudio users, a playable sound file should up in the Viewer pane, and a graphics device window should open.\n\nnew_tg &lt;- make_TextGrid('ex/index.wav',\n                        tierNames = c('Mary', 'John', 'bell'))\n\n\n\n\n\n\nIn the R console, you will see the following text:\nNavigate to the graphics device window and click in the positions where you want TextGrid boundaries for tier Mary\nYou can now click on the image where you want annotation boundaries to be. If you click the Stop locator button in the graphics window, you will see dotted lines in the locations where you clicked:\n\n\n\n\n\nIn the console, you will be asked the following question:\nIs this an interval tier? [y/n]\nI indeed had an interval tier, so I will type y and press enter! If you want a point tier, type n.\nNext up, I will be asked to input the text for labels. I put in b, a, and h. This prompts the following text in the console:\nCheck the resulting annotation and type enter!\nAnd the graphics device window will now also show the text:\n\n\n\n\n\nThis process will loop through however many annotation tiers you choose. When you’re done, the object new_tg (or whatever you choose to name it) will be saved in your environment. You can use this object when making a regular praatpicture figure, by passing it to the tg_obj argument:\n\npraatpicture('ex/index.wav',\n             tg_obj = new_tg)\n\n\n\n\n\n\n\n\nThis now functions as a regular TextGrid!\nIf you want to make annotations like this but you’re working with a larger sound file and don’t want to show all of it, you can use the start and end arguments to show just part o fthe sound file (as when plotting with praatpicture)."
  },
  {
    "objectID": "make_TextGrid.html#showing-the-spectrogram",
    "href": "make_TextGrid.html#showing-the-spectrogram",
    "title": "12  Annotating interactively in R",
    "section": "12.2 Showing the spectrogram",
    "text": "12.2 Showing the spectrogram\nIf you prefer annotating on the basis of the spectrogram, you can do this by setting the show argument to 'spectrogram':\n\nnew_tg &lt;- make_TextGrid('ex/index.wav',\n                        tierNames = c('Mary', 'John', 'bell'),\n                        show = 'spectrogram')\n\nYou will then see an image like this in the graphics window:\n\n\n\n\n\nIt otherwise works the same, but it is a fair bit slower since the spectrogram takes a while to generate."
  },
  {
    "objectID": "make_TextGrid.html#dynamically-converting-sampa-to-ipa",
    "href": "make_TextGrid.html#dynamically-converting-sampa-to-ipa",
    "title": "12  Annotating interactively in R",
    "section": "12.3 Dynamically converting SAMPA to IPA",
    "text": "12.3 Dynamically converting SAMPA to IPA\nIf you want to use IPA characters in your annotation but don’t want to go through the process of finding them, the argument sampa2ipa allows you to type in SAMPA transcriptions and convert them on the fly to IPA.\nWhen I was making the first annotation tier of our sound file above and added the labels b, a, h, that was because I was lazy! These are actually a bilabial implosive, a low back vowel, and a voiced glottal fricative. I just didn’t want to find those symbols. I can do this easily with sampa2ipa set to TRUE:\n\nnew_tg_ipa &lt;- make_TextGrid('ex/index.wav',\n                            tierNames = 'IPA',\n                            sampa2ipa = TRUE)\n\nThis time, I put boundaries in roughly the same locations as above, and when prompted, I will type b_&lt;, A, and h\\, which is the sampa way to annotate these sounds. When prompted to check the resulting annotation, I will now see the following:\n\n\n\n\n\nIf I use the resulting object with praatpicture(), the annotations will be in IPA:\n\npraatpicture('ex/index.wav',\n             tg_obj = new_tg_ipa)"
  },
  {
    "objectID": "talking_praatpicture.html#basic-usage",
    "href": "talking_praatpicture.html#basic-usage",
    "title": "13  Embedding audio",
    "section": "13.1 Basic usage",
    "text": "13.1 Basic usage\ntalking_praatpicture() works essentially just like praatpicture(), and takes all the same arguments (plus a few more). As with praatpicture(), you can use it with just a single argument:\n\ntalking_praatpicture('ex/ex.wav')\n\nIf you’re using RStudio, you should now see this in the Viewer pane:\n\n\nVideo\n\n\nIf you want to save the video instead of showing it in RStudio, you should set the useViewer argument to FALSE and set the outputFile argument to the file name and location you want. By default, it will be saved as praatvid.mp4 in your working directory.\n\ntalking_praatpicture('ex/ex.wav',\n                     useViewer = FALSE)"
  },
  {
    "objectID": "talking_praatpicture.html#what-to-show-what-to-hear",
    "href": "talking_praatpicture.html#what-to-show-what-to-hear",
    "title": "13  Embedding audio",
    "section": "13.2 What to show, what to hear",
    "text": "13.2 What to show, what to hear\nAs in praatpicture(), you can determine exactly which parts of the file to show with the start and end arguments. Here we include just the second and third words:\n\ntalking_praatpicture('ex/ex.wav',\n                     start = 0.34, end = 0.97,\n                     tg_tiers = c('phone', 'word'))\n\n\n\nVideo\n\n\nBy default, what you see is also what you hear, i.e. the sound file is also cropped. This may not be what you want; if showing just a short sound snippet, you want to include a little more audio. This can be controlled separately with the audio_start and audio_end arguments. Here we limit what is shown, but include the entire sound file:\n\ntalking_praatpicture('ex/ex.wav',\n                     start = 0.34, end = 0.97,\n                     audio_start = 0, audio_end = 1.8,\n                     tg_tiers = c('phone', 'word'))\n\n\n\nVideo"
  },
  {
    "objectID": "talking_praatpicture.html#sec-video-qual",
    "href": "talking_praatpicture.html#sec-video-qual",
    "title": "13  Embedding audio",
    "section": "13.3 Image quality, dimensions, and font size",
    "text": "13.3 Image quality, dimensions, and font size\nThe image quality and dimensions of a talking_praatpicture() is controlled with the width and height arguments, giving pixel numbers. The default is 1080 and 720, equivalent to a 720p video. It may suit a presentation better with different dimensions. Here is an example that swaps those dimensions:\n\ntalking_praatpicture('ex/ex.wav',\n                     start = 0.34, end = 0.97,\n                     audio_start = 0, audio_end = 1.8,\n                     tg_tiers = c('phone', 'word'),\n                     width = 720, height = 1080)\n\n\n\nVideo\n\n\nYou can easily use these arguments to get higher image quality. For example, we could set it to be 1920x1080 (i.e. full HD, or 1080p). If you do this, be aware that font size is related to pixel number, so you’ll also want to increase the font size. This is controlled with the pointsize argument, which is set to 25 by default.\nHere is a pristine quality, more wide-screen example:\n\ntalking_praatpicture('ex/ex.wav',\n                     start = 0.34, end = 0.97,\n                     audio_start = 0, audio_end = 1.8,\n                     tg_tiers = c('phone', 'word'),\n                     width = 1920, height = 1080,\n                     pointsize = 40)\n\n\n\nVideo"
  },
  {
    "objectID": "animation.html#basic-usage",
    "href": "animation.html#basic-usage",
    "title": "14  Animations",
    "section": "14.1 Basic usage",
    "text": "14.1 Basic usage\nThe function praatanimation() allows you to make animated praatpicture() style plots. It takes most of the same arguments as praatpicture(), but the numeric variables in praatanimation() can typically take twice as many values.\nFor example, we could pass a vector of two numbers to start and a vector of two numbers to end. The first of the two numbers will then determine where the animation begins, and the second will determine where it ends. We can use this to gradually zoom in to a sound file:\n\npraatanimation('ex/ex.wav',\n               start = c(0, 0.34), \n               end = c(1.8, 0.97))\n\n\n\n\n\n\nYou can control how many images this animation consists of with the n_frames argument, and you can control how quickly the animation changes with the frameRate argument. Here is the same animation with more frames, and more frames per second:\n\npraatanimation('ex/ex.wav',\n               start = c(0, 0.34), \n               end = c(1.8, 0.97),\n               frameRate = 50,\n               n_frames = 100)\n\n\n\n\n\n\nBy default, these animations are shown in the Viewer pane for RStudio users. You can save them by setting the useViewer argument to FALSE and by specifying a file name. By default, animations are looping GIFs, but you can disable looping with the loop argument, and you can save animations as mp4 videos with the outputFormat argument.\nYou can control the dimensions and quality of the resulting image, as well as font size, in the same way as we saw in Section 13.3."
  },
  {
    "objectID": "animation.html#some-more-examples-because-its-fun",
    "href": "animation.html#some-more-examples-because-its-fun",
    "title": "14  Animations",
    "section": "14.2 Some more examples (because it’s fun!)",
    "text": "14.2 Some more examples (because it’s fun!)\nAn especially nice-looking use of praatanimation() is to move through the intensity plots by manipulating the start and end arguments:\n\npraatanimation('ex/ex.wav',\n               start = c(0, 1.3), \n               end = c(0.5, 1.8),\n               n_frames = 150,\n               frames = c('sound', 'intensity', 'TextGrid'))\n\n\n\n\n\n\nI also find that these animations are very useful for explaining the difference between narrow-band and broad-band spectrograms:\n\npraatanimation('ex/ex.wav',\n               spec_windowLength = c(0.003, 0.04))\n\n\n\n\n\n\nYou can animate as many parameters as you want in one plot, so try and have fun with it! I’ll leave the source code for the following animation as an exercise to the reader:"
  },
  {
    "objectID": "emu.html#basic-usage",
    "href": "emu.html#basic-usage",
    "title": "15  EMU-SDMS integration",
    "section": "15.1 Basic usage",
    "text": "15.1 Basic usage\nemupicture() can only be used if you have an EMU database loaded in R. We’ll load a toy database for this purpose:\n\nlibrary(emuR)\ndb &lt;- load_emuDB('ex/aarhus_emuDB')\n\nINFO: Checking if cache needs update for 1 sessions and 1 bundles ...\nINFO: Performing precheck and calculating checksums (== MD5 sums) for _annot.json files ...\nINFO: Nothing to update!\n\n\nIf we have a look at this database, we’ll see that it has just one ‘session’ and one ‘bundle’ (i.e. a single sound file).\n\nserve(db)\n\nYou should now see this view:\n\nYou’ll see just two annotation tiers, but there are also some hidden ones in this database, which we can see with the list_levelDefinitions() function:\n\nlist_levelDefinitions(db)\n\n\n\n  \n\n\n\nPlotting the view you see when you serve() the database in a praatpicture()-like manner is very simple. There are just a few arguments that are different: emupicture() requires the handle of a loaded EMU database db_handle, a bundle name, and optionally a session name. We can see what these are in the image above, and if you’re used to the EMU-SDMS, these concepts should all be familiar.\nHere, we’ll load the view we see in the database, zoomed in a bit and plotting just the same two annotation tiers on the picture above. These arguments will all be familiar from previous sections of this manual.\n\nemupicture(db_handle = db,\n           session = '_044',\n           bundle = '044nabo-nasal-alv-low-nst-NA-NA-NA-NA-NA',\n           start = 1.4, end = 3.1,\n           tg_tiers = c('phone', 'landmarks'))\n\n\n\n\n\n\n\n\nemupicture() will otherwise accept all the same arguments as praatpicture()."
  },
  {
    "objectID": "emu.html#embedding-audio",
    "href": "emu.html#embedding-audio",
    "title": "15  EMU-SDMS integration",
    "section": "15.2 Embedding audio",
    "text": "15.2 Embedding audio\nWe saw in Chapter 13 that it’s possible to use the function talking_praatpicture() to make single-frame videos with embedded audio, which is very useful for presentations. This trick is also possible using emupicture(), by setting the argument talking = TRUE.\n\nemupicture(db_handle = db,\n           session = '_044',\n           bundle = '044nabo-nasal-alv-low-nst-NA-NA-NA-NA-NA',\n           start = 1.4, end = 3.1,\n           tg_tiers = c('phone', 'landmarks'),\n           talking = TRUE)\n\n\n\nVideo\n\n\nWhen using emupicture() with talking = TRUE, all the arguments from talking_praatpicture() can be used."
  },
  {
    "objectID": "emu.html#sec-ssff",
    "href": "emu.html#sec-ssff",
    "title": "15  EMU-SDMS integration",
    "section": "15.3 Plotting data from SSFF files",
    "text": "15.3 Plotting data from SSFF files\nIf you plot derived signals like pitch with emupicture(), it’ll by default be calculated on the fly, as in praatpicture():\n\nemupicture(db_handle = db,\n           session = '_044',\n           bundle = '044nabo-nasal-alv-low-nst-NA-NA-NA-NA-NA',\n           start = 1.4, end = 3.1,\n           tg_tiers = c('phone', 'landmarks'),\n           frames = c('sound', 'pitch', 'TextGrid'),\n           pitch_plotType = 'speckle', \n           pitch_freqRange = c(120, 300))\n\n\n\n\n\n\n\n\nAs we’ve seen previously, praatpicture() allows you to calculate these derived signals in Praat, save them, and plot those signals instead of calculating signals on the fly. If you’re an EMU user, you’re likely familiar with SSFF (simple signal file format) tracks, which is a way of associating any signal, derived or otherwise, with a database. Using emupicture(), you can choose to plot SSFF tracks instead of calculating signals on the fly.\nOur toy database has two different SSFF tracks associated with it, which we can check with the list_ssffTrackDefinitions() function.\n\nlist_ssffTrackDefinitions(db)\n\n\n\n  \n\n\n\nf0 is a pitch track calculated using Praat, and rf0 is a pitch track calculated using REAPER. If you want to use one of these SSFF tracks instead of calculating pitch on the fly, you can do it using the pitch_ssffExt argument. There are similar arguments for formant_ssffExt and intensity_ssffExt.\nHere’s the pitch track calculated using Praat:\n\nemupicture(db_handle = db,\n           session = '_044',\n           bundle = '044nabo-nasal-alv-low-nst-NA-NA-NA-NA-NA',\n           start = 1.4, end = 3.1,\n           tg_tiers = c('phone', 'landmarks'),\n           frames = c('sound', 'pitch', 'TextGrid'),\n           pitch_plotType = 'speckle', \n           pitch_freqRange = c(120, 300),\n           pitch_ssffExt = 'f0')\n\n\n\n\n\n\n\n\nAnd here’s the pitch track calculated using REAPER:\n\nemupicture(db_handle = db,\n           session = '_044',\n           bundle = '044nabo-nasal-alv-low-nst-NA-NA-NA-NA-NA',\n           start = 1.4, end = 3.1,\n           tg_tiers = c('phone', 'landmarks'),\n           frames = c('sound', 'pitch', 'TextGrid'),\n           pitch_plotType = 'speckle', \n           pitch_freqRange = c(120, 300),\n           pitch_ssffExt = 'rf0')"
  }
]